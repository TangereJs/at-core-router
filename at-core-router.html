<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../at-core-signals/at-core-signals.html">


<dom-module id="at-core-router">

  <style>
    :host {
      width: 100%;
      display: block;
    }
    
    #content {
      position: relative;
    }
    
    .view {
      box-sizing: border-box;
      display: block;
      position: absolute;
      background-color: transparent;
      min-width: 100%;
      min-height: 100%;
      width: 100%;
      margin: 0;
      left: 0;
      will-change: left;
      transform: translateZ(0);
    }
    
    .view.back {
      left: -100%;
      will-change: left;
    }
    
    .view.center {
      left: 0;
      will-change: left;
    }
    
    .view.forward {
      left: 100%;
      will-change: left;
    }
    
    .view.transition {
      transition: all 0.2s ease-in-out;
      -webkit-transition: all 0.2s ease-in-out;
    }
    
    .androidFix {
      overflow: hidden !important;
      overflow-y: hidden !important;
      overflow-x: hidden !important;
      display: none;
    }

  </style>

  <template>
    <at-core-signals on-navigate-to="navigateTo" on-session-ready="start"></at-core-signals>
    <div id="content"></div>
  </template>
</dom-module>

<script>
  (function () {

    var stateHistory = []; // used to automatically detect a "back" navigation

    var current = {
      //stateManager: null,   // reference to 'this'
      appFrame: null, // frame / scaffold element
      viewState: null, // active state
      boundElement: null, // current active content element, bound to viewState args
      boundVars: null, // collection of names for bound variables of current component
      direction: "none", // forward, back, none  for view transition
      observer: null // object observer for view arg changes
    }


    var getVendorPrefix = function () {
      var styles = window.getComputedStyle(document.documentElement, '');
      var pre = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o']))[1];
      var vPrefix = {
        lowercase: pre,
        css: '-' + pre + '-'
      };

      return vPrefix;
    };

    // Names for transition end events on various platforms
    var transitionEndEventNames = {
      webkit: "webkitTransitionEnd",
      moz: "transitionend",
      ms: "transitionend",
      o: "otransitionend"
    };

    if ('scrollRestoration' in history) {
      // Back off, browser, I got this...
      history.scrollRestoration = 'manual';
    }

    function getViewStateFromHash(hash) {
      hash = hash || window.location.hash;
      var vs = {};
      args = {};

      if (hash.indexOf("#!") == 0) {
        hash = hash.substr(2);
      } else if (hash.indexOf("#") == 0) {
        hash = hash.substr(1);
      }
      var hashes = hash.split('?');
      vs['view'] = hashes[0];

      if (hashes.length > 1) {
        hashes = hashes[1].split('&');

        for (var i = 0; i < hashes.length; i++) {
          var hash = hashes[i].split('=');
          if (hash.length > 1) {
            args[hash[0]] = decodeURIComponent(hash[1]);
          } else {
            args[hash[0]] = "";
          }
        }
      }
      vs.args = args;
      return vs;
    }

    function encodeViewState(vs, initial) {
      var r = "";
      var args = Object.getOwnPropertyNames(vs.args).sort();
      for (var i = 0; i < args.length; i++) {
        var argv = vs.args[args[i]];

        if (!initial) {
          var vname = args[i];
          //var vnew = current.boundElement[vname];
          var vnew = vs[vname];
          var property = current.boundElement.properties[vname];
          var defaultValue;
          if (property != undefined && property.value != undefined) {
            defaultValue = property.value;
          }
         
          if (typeof defaultValue != "undefined" && vnew == defaultValue) {
            continue;
          }
        }
        r += (r > "" ? "&" : "") + args[i] + (argv != "" ? "=" + encodeURIComponent(argv) : "");
      }

      r = vs.view + (r > "" ? "?" + r : "");
      
      return r;
    }


    function TransitionEndEventName() {
      return transitionEndEventNames[getVendorPrefix().lowercase];
    }

    function fireEvent(eventName, viewState) {
      var event = new CustomEvent(eventName, {
        "detail": current
      });
      document.dispatchEvent(event);
    }


    Polymer({
      is: 'at-core-router',
      _scopeCssViaAttr: true,
      properties: {
        defaultView: {
          type: String,
          value: "at-app/at-home"
        },
        primaryColor: {
          type: String,
          value: "",
          observer: "colorChanged"
        },
        defaultColor: {
          type: String,
          value: "lightGreen"
        },
        caption: {
          type: String,
          value: "",
          observer: "captionChanged"
        },
        enableBack: {
          type: Boolean,
          value: false
        },
        context: {
          type: Object,
          value: null
        }
      },
      colorChanged: function (value, old) {
        var color = value || this.defaultColor || this.properties.defaultColor.value;
        Polymer.signal("app-color", value);
      },
      captionChanged: function (value, old) {
        document.title = value;
        Polymer.signal("app-caption", value);
      },
      open: function (view) {

        if (!view) {
          view = this.defaultView;
        }

        // signal to close side panel before navigating
        Polymer.signal("before-navigate", view);

        view = "#!" + view;
        window.location.hash = view;
      },

      // the view changed one of its args -> persistent to Url
      viewChangedArg: function (e) {
        
        var boundvars = this.context.boundVars;
        var vs = this.context.viewState;

        var oldState = encodeViewState(vs);
        //var oldState = encodeViewState(getViewStateFromHash(window.location.hash));
        
        for (var i in boundvars) {
          if (boundvars.hasOwnProperty(i)) {
            var vname = boundvars[i];
            var vold = vs.args[vname];
            var vnew = this.context.boundElement[vname];
            var property = this.context.boundElement.properties[vname];
            var defaultValue = undefined;
            if (property != undefined && property.value != undefined) {
              defaultValue = property.value;
            }
 
            //console.log("history vname:" + vname + ", vold:" + vold + ", vnew:" + vnew + ", default:" + defaultValue);

            // parameter value changed -> update hash
            if (vold == undefined || vnew != vold) {
              vs.args[vname] = vnew;
            }

            // don't save default values in viewState
            if (typeof defaultValue != "undefined" && vnew == defaultValue) {
              delete vs.args[vname];
            }
          }
        }

        // get new normalized hash
        var state = encodeViewState(vs);         

        // update hash if viewState changed
        if (state != oldState) {
            
          window.location.hash = "#!" + state;

          // save new hash to navigation stack
          stateHistory.push(state);

          // update back button status
          Polymer.signal("navigate-back-status", stateHistory.length > 1);

          // save current viewState
          current.viewState = vs;
        }
        
      },

      viewShow: function (e, elementName) {

        var appFrame = e.detail.appFrame;
        var vs = e.detail.viewState;
        var viewName = vs.view;

        var newElem = document.createElement(elementName);
        var trans = e.detail.direction;

        // todo: improve handle/detect error
        if (typeof newElem.properties == "undefined") {
          alert("View " + elementName + " not found");
          return;
        }

        var newView = newElem;
        var currentView = e.detail.boundElement;

        // load initial values and bind them
        if (typeof newElem.properties != "undefined") {
          var boundvars = Object.getOwnPropertyNames(newElem.properties);

          if (newElem.caption) {
            this.caption = newElem.caption;
          }

          if (newElem.primaryColor) {
            this.primaryColor = newElem.primaryColor;
          } else {
            // use default color when no custom color is assigned
            this.primaryColor = this.defaultColor;
          }

          current.boundVars = boundvars;

          for (var i in boundvars) {
            if (boundvars.hasOwnProperty(i)) {
              var vname = boundvars[i];
              var vval = vs.args[vname];
              if (vval != undefined) newElem[vname] = vval;
              newElem.addEventListener(Polymer.CaseMap.camelToDashCase(vname) + '-changed', e.detail.appFrame.viewChangedArg.bind(e.detail.appFrame), false);
            }
          }
        }

        // save reference to now bound element
        e.detail.boundElement = newElem;

        // position views
        if (currentView) {

          newView.className = "view " + trans;
          currentView.className = "view center";

          // remove previous view when animation is finished
          currentView.addEventListener(TransitionEndEventName(), function (e) {          
            
            if (e.target.classList.contains("hiddenview")) {
              var ctr = Polymer.dom(appFrame.$.content).removeChild(e.target);
              ctr = null;
              delete ctr;
            }

            Polymer.signal("busy-end-async"); // view change finished when transistion is finished     

            document.body.scrollTop = 0;      // ensure that view is showing at top
            var el = document.getElementById("mainwrapper");
            el || el.scrollIntoView();

            if (!('scrollRestoration' in history)) {
              setTimeout(function () {
                window.scrollTo(0, 0);
                el || el.scrollIntoView();
              }, 250);
            }

          });

        } else {

          newView.className = "view center";

        }

        // remove hidden views which didn't trigger TransitionEndEvent
        //     because of user interaction was faster then animation time
        var hidden = Polymer.dom(appFrame.$.content).querySelectorAll(".hiddenview");

        for (var i = 0; i < hidden.length; i++) {
          var ctr = Polymer.dom(appFrame.$.content).removeChild(hidden[i]);
          ctr = null;
          delete ctr;
        }

        var parent = appFrame.$.content;
        Polymer.dom(parent).appendChild(newElem);

        // transform ShadyDom styles of innerHTML
        if (!Polymer.Settings.useShadow) Polymer.StyleTransformer.dom(parent, this.is, true);

        // Force reflow to make sure the style changes
        // are applied before rendering the element
        Polymer.dom.flush();
        document.body.offsetWidth;


        // scroll to top - Chrome & Android require workaround or scrollTop fails
        var androidFixRequired = (navigator.userAgent.toLowerCase().indexOf("android") > -1) || (navigator.userAgent.toLowerCase().indexOf("chrome") > -1);
        androidFixRequired = false;
        if (androidFixRequired) parent.classList.add("androidFix");
        //parent.scrollTop = 0;        
        if (androidFixRequired) parent.classList.remove("androidFix");

        //document.body.scrollTop = 0;        
        

        // Position the new page and the current page at the ending position of their animation
        // with a transition class indicating the duration of the animation
        if (currentView) {

          // notify currentView about unload
          if (typeof currentView.detach == "function") {
            currentView.detach(e.detail);
          }

          Polymer.dom.flush();
          
          this.async(function () {
            
            newView.className = "view transition center";            
            currentView.className = "view hiddenview transition " + (trans === "back" ? "forward" : "back");
            //console.log("router 100 animate " + trans);
           
          }, 100);

        } else {
          // initial view shows without transistion
          newView.className = "view center";
          Polymer.signal("busy-end-async"); // no tranisition, so view changed finished immediately
          //console.log("router no animation");
        }

        // call viewReady of new view element
        if (typeof newElem.viewReady == "function") {
          newElem.viewReady(e.detail);
        }        

        // signal new view -- allowing e.g. side panel to highlight current selection        
        Polymer.signal("active-view-changed", {
          name: elementName
        });

      },

      viewChanged: function (e) {

        var appFrame = e.detail.appFrame;
        var vs = e.detail.viewState;
        var viewName = vs.view;

        // use default view name?
        if (viewName == "") viewName = e.detail.appFrame.defaultView;

        // add default prefix if no prefix is provided
        if (viewName.indexOf("-") < 0) viewName = "at-" + viewName;

        // remove .variant
        if (viewName.indexOf(".") >= 0) {
          viewName = viewName.substr(0, viewName.indexOf("."));
        }

        // get element name
        var elementName = viewName.substring(viewName.indexOf("/") + 1);

        // update back button status
        Polymer.signal("navigate-back-status", stateHistory.length > 1);

        var compUrl = document.URL.indexOf("/components/") >= 0 ? "../" : "components/";
        if (window.ComponentsBase != undefined) compUrl = window.ComponentsBase;

        // load view from other component (viewName = component-name/view-name) or from localfolder (view-name)
        var importPath = viewName.indexOf("/") >= 0 ? compUrl + viewName + ".html" : viewName + ".html";

        // view change starts        
        Polymer.signal("busy-start-async");

        // import elementName
        appFrame.async(function () {         
          e.detail.appFrame.importHref(importPath, function () {
            e.detail.appFrame.viewShow(e, elementName);
          }, function () {
            Polymer.signal("busy-end-async");
            alert("ERROR: failed to load view " + e.detail.viewState.view);
            location.hash = ""; // clear current hash 
            location.reload(); // go to start app by reloading without hash
          });
        }, 20);
      },

      viewArgsChanged: function (e) {
        var vs = e.detail.viewState;
        var elem = e.detail.boundElement;

        // update bound values
        var boundvars = Object.getOwnPropertyNames(elem.properties);
        for (var i = 0; i < boundvars.length;i++) {
          var vname = boundvars[i];
          var vval = vs.args[vname];
          var property = current.boundElement.properties[vname];
          var defaultValue;
          if (property != undefined && property.value != undefined) {
            defaultValue = property.value;
          }
          //elem[vname] = (vval == undefined ? "" : vval);
         
          if (vval != undefined) elem[vname] = vval;
          if (vval == undefined && defaultValue != undefined) elem[vname] = defaultValue;
        }
      },

      hashChanged: function (e) {

        var newVs = getViewStateFromHash();

        // ignore if view state didn't really change
        if (encodeViewState(current.viewState, true) == encodeViewState(newVs, true)) return;

        // update nav history, detect direction
        var l = stateHistory.length;
        var state = encodeViewState(newVs);

        if (l === 0) {
          stateHistory.push(state);
          current.direction = "forward";
        }
        if (state === stateHistory[l - 2]) {
          stateHistory.pop();
          current.direction = "back";
        } else {
          stateHistory.push(state);
          current.direction = "forward";
        }


        // detect type of change
        var eventName = "view-changed";
        if (newVs.view == current.viewState.view) {
          current.direction = "none";
          eventName = "view-args-changed";
        }

        // save new viewState
        current.viewState = newVs;
                
        // update back button status
        Polymer.signal("navigate-back-status", stateHistory.length > 1);

        // fire event
        fireEvent(eventName, newVs);
      },

      start: function () {

        // save atApp reference
        current.appFrame = this;

        // get initial viewState
        var vs = getViewStateFromHash();

        // set default view if no view name exists
        if (vs.view == "") vs.view = this.defaultView;

        // set initial, normalized hash
        var state = encodeViewState(vs, true);
        window.location.hash = "#!" + state;

        // save initial hash to navigation stack
        stateHistory.push(state);

        // save initial viewState
        current.viewState = vs;

        // list to hash change events
        window.addEventListener("hashchange", this.hashChanged.bind(this));

        // fire view-changed to load initial view
        fireEvent("view-changed", vs);
      },
      navigateTo: function (e) {

        var view = e.detail;

        // navigate to external url
        if (view.indexOf("://") > 0 || view.indexOf("/") == 0) {
          location.replace(view);
          return;
        }

        if (view.indexOf("#!") == 0) {
          view = view.substring(2);
        }

        if (view.indexOf("#") == 0) {
          view = view.substring(1);
        }

        this.open(view);

      },
      ready: function () {

        this.context = current;

        document.addEventListener('view-changed', this.viewChanged, false);
        document.addEventListener('view-args-changed', this.viewArgsChanged, false);
        document.addEventListener('router-navigate-to', this.navigateTo.bind(this), false);
      }


    });
  })();
</script>
